# 파이프
- 프로세스 간의 데이터를 주고받기 위한 또 다른 방법이다.
- 파이프는 우선 단순한 통로이다. 부가적인 기능이 없다.
- 조금 더 상세하게 말하자면, 누가 보내는거고 누가 받는건지에 대한 정보가 없다.
- 파일처럼 fd로 관리되는데, 쓰기용 fd에서 쓰면 그냥 써지는 거고 읽기용 fd에서 읽어가면 읽어가지는 거다. 누가 쓰던 읽던 그냥 fd로 읽고 쓰면 되는거다.
- 그래서 양방향에서 읽고 쓸 수는 있지만, 제대로 동작하는걸 보장하기 위해서는 단방향으로 써야하는거다. 물론 양뱡향으로는 파이프를 두개 쓰면 된다.
- FIFO 방식으로 처리된다. 특이한점은 읽고 난 데이터는 삭제된다는 점이다. 때문에 파일처럼 읽고 쓰지만, lseek()는 동작하지 않는다.
- 읽고 난 데이터가 삭제된다는 점 덕분에 자동으로 동기화가 지원된다. 비어있는 파이프를 읽을 때는 자동으로 blocking 상태로 들어간다. 파이프에 어떤 내용이 들어왔을 때 운영체제가 깨워서 읽으라고 시킨다.
- 파이프도 fork()를 통해 상속된다. 왜냐면 파일처럼 다뤄지니까!
    ```c
    int main() {
        char ch[10];
        int pid, p[2];

        if (pipe(p) == -1) {
            perror("pipe call");
            exit(1);
        }

        if ((pid = fork()) == 0) {
            close(p[1]);
            read(p[0], ch, 10);
            printf("%s\n", ch);
            exit(0);
        }

        close(p[0]);
        scanf("%s", ch);
        write(p[1], ch, 10);
        wait(0);
        exit(0);
    }
    ```
- 파이프를 비롯한 멀티 프로세스 프로그래밍을 할땐, 그림을 그려보고 코드를 분리해서 작성하자, 그리고 blocking 되는 위치와 signal을 받는 작업을 신경쓰며 코드를 작성해야 한다.
## Blocking
- 파이프는 우선 자동으로 blocking 작업으로 수행한다.
- 메모리 매핑을 생각해보면, read() 했을 시 내용이 없으면 그냥 읽은 거 없이 반환된다.
- 파이프는 비어있을 경우 read()를 실행하면 scanf()처럼 blocking 상태가 된다.
- 파이프가 가득 찬 경우 write()를 실행하면 역시 자동으로 blocking 상태가 된다. 누가 읽어가면 다시 쓰기 작업을 수행한다. pipe는 file 처럼 동작하지만, file보다 굉장히 작아서 가득 차는 상황을 제법 볼 수 있다.
## 파이프 닫기
### 쓰기 전용 파이프 닫기
- 다른 writer가 없는 경우 read 를 위해 기다리던 프로세스에게 0을 리턴한다. EOF와 같은 효과라고 볼 수 있다.
### 읽기 전용 파이프 닫기
- 다른 reader가 없는 경우 writer들은 SIGPIPE 시그널을 받는다. 핸들링 하지 않으면 프로세스가 종료된다.
- 핸들링 처리 후에는 write가 -1을 반환한다.
## 파이프 폴링 pipe polling
- 여러 pipe를 차례로 폴링하면서 읽어야 하는 경우를 생각해보자. (Server는 하나 Client는 여럿)
- 첫번째 파이프의 클라이언트가 쓰지 않는다면 무한정 blocking 하면서 다른 클라이언트의 파이프를 확인하지 못하게 된다. 따라서 non-blocking으로 작동해야하는 경우가 있다.
    ```c
    fcntl(fd, F_SETFL, O_NONBLOCK)
    ```
    이렇게 쓰면 된다.
- 쓰기 전용일 경우, pipe가 차면 blocking 없이 -1 리턴
- 읽기 전용일 경우, pipe가 비었으면 blocking 없이 -1 리턴
- errno는 EAGIN이 된다.