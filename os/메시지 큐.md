# Message queue
- 파이프는 읽기 끝과 쓰기 끝이 연결되어야 사용할 수 있다.
- 메세지 큐는 서로의 실행을 기다리지 않아도 된다.
- 메세지 큐에 쓰고나서 프로세스를 종료해도 메세지 큐에 내용이 남아있다.
- 파이프는 연결이 끊어지면 그냥 줄줄 새나가고 내용이 남아있지 않다.
## 만들기
- 일단 IPC 장비들은 비싸다. 메세지 큐도 이 중에 하나다.
- 시스템 전체가 공유하기때문에 유일한 키 값을 사용해야한다. ftok(path, int) 로 생성하면 path의 inode, device 정보와 int 값을 참고하여 유일한 키값을 생성한다.
- 다른 프로세스에서도 동일한 메세지 큐를 사용하려면 해당 path와 int를 사용하면 된다.  
- 그 다음 키값으로 메세지 큐를 만들거나 만들어진 큐를 가져온다.
```C
int main() {
  int qid;
  key_t key;

  key = ftok("key", 3);
  qid = msgget(key, IPC_CREAT | 0600);
  ...
}
```
## 보내기
```C
struct q_entry {
  long mtype;
  int data;
};

int main() {
  int qid;
  struct q_entry msg;

  ...

  msg.mtype = 1;
  msg.data = 20;

  msgsnd(qid, &msg, sizeof(int), 0);

  ...
}
```
- 메세지 큐에 보낼땐 반드시 long 타입의 mtype이 포함되어야 한다. 다양한 용도로 사용할 수 있고, 메세지 큐의 핵심이라 볼 수 있다. 반드시 양의 정수로 설정해야한다.
- 메세지의 크기는 long 타입을 제외한 크기를 넣으면 된다.
- 마지막 플래그에는 IPC_NOWAIT을 넣어서 blocking 되지 않도록 설정할 수 있다.
## 받기
```C
int main() {
  ...
  msgrcv(qid, &msg, sizeof(int), 0, 0);
  ...
}
```
- 뒤에서부터 살펴보자. 제일 뒤는 플래그 값이다. 역시 IPC_NOWAIT 옵션이 존재한다. 하나 더 존재하는데 MSGNOERROR 옵션이다.
- 원래는 메세지보다 size가 작으면 오류가 발생하지만, 작으면 작은만큼 잘라서 받겠다는 의미이다.
- 그 다음이 가장 중요한데, 설정 값에 따라 메세지를 받는 순서가 달라진다.
  - 0으로 설정: 큐에 있는 순서대로 받아온다. 가장 평범한 방식
  - 양의 정수로 설정: 해당 값을 가지면서(mtype), 큐의 가장 첫 메세지
  - 음의 정수로 설정: 해당 값의 절대값보다 작거나 같은 것 중 최소값을 갖는 첫 메세지
    - 조금 더 설명이 필요한데, -3으로 설정하면 1, 2, 3 순으로 받는다.
      큐에 1 2 3 1 1 3 3 2 가 있다면 -> 1 1 1 2 2 3 3 3 순으로 받는다.
## 큐 제어
- 큐에 대한 정보를 가져오거나 제거할 때 사용한다.
```C
int main() {
  struct msqid_ds stat;
  ...
  msgctl(qid, IPC_STAT, &stat);
  ...
}
```
- 플래그를 IPC_RMID로 설정하면 큐를 제거한다.
- 큐의 정보를 가져오면 파일의 lstat이랑 비슷한 정보를 제공한다.
