# DFS / BFS
- stack은 list 사용하면 된다. append(), pop()
- queue는 deque를 사용하자. 그냥 list는 기능은 해도 시간 복잡도가 높다. append(), popleft()
## DFS
1. 탐색 시작 노드를 스택에 넣고 방문 처리
2. 스택 최상단 노드와 인접한 노드 && 방문하지 않은 노드 -> 스택에 넣고 방문 처리
3. 방문하지 않은 인접 노드가 없으면 스택에서 팝
4. 2-3 반복하지 못할때까지 반복
### 필요 요소
- 재귀 함수
- 그래프
- 시작 노드
- 방문여부
- dfs(graph, v, visited) 형태로 구성
    ```py
    def dfs(graph, v, visited):
        visited[v] = True # 꺼내면서 방문처리
        print(v, end=' ') # 작업
        for i in graph[v]: # v 노드와 인접한 노드들
            if not visited[v]: # 방문하지 않았다면
                dfs(graph, i, visited) # 재귀(스택)
    ```
## BFS
1. 탐색 시작 노드를 큐에 넣고 방문 처리
2. 큐에서 노드를 꺼내고 해당 노드와 인접한 노드 중 방문하지 않은 노드를 _모두_ 큐에 넣고 방문처리.
3. 2 반복하지 못할때까지 반복
### 필요 요소
- 큐
- 그래프
- 시작 노드
- 방문여부
    ```py
    def bfs(graph, v, visited):
        queue = deque([v]) # 큐와 시작 노드 넣기
        visited[v] = True # 방문처리
        while queue: # 큐가 빌때까지 (인접한 노드가 다 방문해서 큐에 안쌓이기 시작할때~)
            cur = queue.popleft() # 작업할 노드 꺼내기
            print(cur, end=' ') # 작업하기
            for i in graph[cur]:
                if not visited[i]:
                    queue.append(i)
                    visited[i] = True # !넣으면서! 방문처리
    ```
### 사용
- 간선 가중치가 동일할때 최단거리 측정하기

## 방문처리
- 결국 방문처리 -> 작업하기는 동일하다.
- 다만 재귀함수 입장에서는 재귀실행이 곧 함수의 첫 줄로 이어지며 바로 작업하는거니까 그때 방문 처리를 하면 되고,
- 큐에 넣을때는 언제 꺼내져서 작업이 될 지 모르니까, 꺼내기 전까지 방문처리를 못하면 중복으로 들어갈 수 있다. 그래서 넣을 때 방문처리를 해주는 것
- 사실 재귀함수도 넣을 때 방문처리를 하는거랑 마찬가지 인데, 재귀함수를 실행한다 => 스택에 넣는다(바로 실행됨) => 방문처리
- 큐 처럼 시작 노드에 대한 사전 작업을 진행하면, 재귀 실행 전 코드에서 방문 처리를 해도 무방하다.